3강 this 키워드를 알아보자 1. 함수와 Object에서 사용하면?
*전역변수 : 코드 내 모든 곳에서 참조해서 쓸 수 있는 범용적인, 범위가 넓은 변수입니다. 
그냥 script태그 내에 쌩으로 var 변수 하나 만들면 그건 자연스레 전역변수가 됩니다.  

1-2. strict mode일 때 함수 안에서 쓰면 this는 undefined 입니다. 
<script>
  'use strict';

  function 간지나는함수(){
    console.log(this)
  }
  간지나는함수();
  
</script>
IE 10버전 이상에선 'use strict'라는 키워드를 페이지 최상단에 추가하면 
strict mode로 자바스크립트를 작성가능합니다. 
strict mode에선 var 키워드 없이 변수를 선언하거나, 
변수를 arguments라는 이상한 키워드로 선언하거나 그런 실수를 방지해줍니다. 
strict mode에선 this 키워드를 일반함수 안에서 불렀을 때 undefined라는 값으로 강제로 지정해줍니다. 

2. object 자료형 내에 함수들이 있을 수 있는데 거기서 this값은 '주인님'을 뜻합니다. 
여러분 object 자료형에 함수같은거 집어넣을 수 있다는거 아셨습니까.
var 오브젝트1 = {
  data : 'Kim',
  간지함수 : function(){ console.log('간지') } 
}
글자나 숫자 집어넣듯이 오브젝트 내에도 저렇게 함수를 집어넣을 수 있습니다. 
그럼 함수를 어떻게 꺼내쓰냐면 
var 오브젝트1 = {
  data : 'Kim',
  간지함수 : function(){ console.log('간지') } 
}
오브젝트1.간지함수();

이렇게 쓰시면 됩니다. 그럼 콘솔창에 '간지'라는 글자가 출력되겠군요.
오브젝트에 들어가는 함수들을 있어보이는 전문용어로 메소드 method라고 칭합니다. 

근데 메소드 안에서 this를 쓰면 신기한 값이 나옵니다. 바로 주인님이라는 값인데 
var 오브젝트1 = {
  data : 'Kim',
  간지함수 : function(){ console.log(this) } 
}
오브젝트1.간지함수();

간지라는 단어 대신 this라는 키워드를 출력시키면 어떻게되나요?
콘솔창에 { data : 'Kim', 간지함수 : f } 뭐 이런값이 출력되지않습니까? 
이게 뭐냐면 그냥 여러분이 방금 만든 오브젝트1입니다. 
그래서 메소드안에서 this를 쓰시면 this는 메소드를 가지고 있는 오브젝트를 뜻합니다. 
쉽게 외우고싶다면 this는 '메소드의 주인님'을 지칭합니다. 

*그럼 밑의 예제의 this는 무슨 값이 출력될까요? 

var 오브젝트2 = {
  data : {
    간지함수 : function(){ console.log(this) }
  }
}
오브젝트2.data.간지함수();

답이 무엇이냐면
별거없고 오브젝트의 메소드안에서 썼을 때 this는 메소드를 담고있는 주인님을 뜻하기 때문에
간지함수()를 담고있는 주인님인 오브젝트2.data 라는게 위의 this랑 동일한 뜻입니다. 
 
그래서 코드(1) 코드(2) 둘다 자바스크립트 입장에서 보면 똑같단 이야기입니다. 

<script>

  (1)
  function 간지나는함수(){
    console.log(this)
  }

  (2)
  window.간지나는함수 = function(){ console.log() };
  
</script>
(2)문법은 window라는 오브젝트에 함수 자료를 추가하는 문법일 뿐입니다. 어려운거 없습니다. 
아무튼 결론은 전역함수 만들거나 전역변수 만드시면 저렇게 window {오브젝트} 안에 담긴다는 소리입니다. 
우리가 일부러 하지 않아도 변수나 함수 쌩으로 만들면 자바스크립트가 자동으로 알아서 window안에 담습니다. 
(변수 강의시간에 window 오브젝트에 대해 잠깐 더 알아볼 예정입니다)

4강 this 키워드를 알아보자 2. event listener와 constructor
3. constructor 안에서 쓰면 constructor로 새로생성되는 오브젝트를 뜻합니다. 
자바스크립트에서 오브젝트를 비슷한걸 여러개 만들고 싶을 경우
오브젝트를 복사하는게 아니라 constructor라는걸 만들어서 사용합니다.
쉽게 말하면 constructor는 오브젝트 복사해서 생성해주는 기계입니다. 
기계를 어떻게 만드는지 알아봅시다. 

function 기계(){
  this.이름 = 'Kim';
}
이게 기계 만드는 법입니다. 

함수 문법을 이용해서 만드신 후, 안에 this. 어쩌구를 추가해주시면 됩니다. 
여기서의 this는 기계로부터 새로 생성될 오브젝트들을 의미합니다. 
그럼 this.이름 = 'Kim' 이건 무슨 뜻일까요?
새로생성되는 오브젝트의 이름 key값에 'Kim'이라는 value를 집어넣어주세요
라는 뜻입니다.

▼ 이건 참고로 알아두시면 좋은 기계에서 오브젝트 뽑는 법입니다. 
function 기계(){
  this.이름 = 'Kim'
}
var 오브젝트 = new 기계();
이렇게 new 키워드를 이용하면 새로운 오브젝트를 꺼낼 수 있습니다. 
그리고 새로운 오브젝트는 {이름 : 'Kim'} 이라는 값을 가지고 있습니다.  (this 라는 키워드 덕분에요)

4. eventlistener 안에서 쓰면 this는 e.currentTarget이라는 의미입니다.  
document.getElementById('버튼').addEventListener('click', function(e){
  console.log(this)
});
여기서 this를 소환하면 이것은 바로 e.currentTarget이라는 뜻과 똑같은 의미입니다. 
e.currentTarget은 지금 이벤트가 동작하는 곳을 뜻합니다. 
매우 간단히 설명하면 지금 addEventListener 부착된 HTML 요소를 뜻한다고 보시면 됩니다. 
의심되면 e.currentTarget, this, document.getElementById('버튼') 이거 세개를 각각 출력해보시면 됩니다. 
이게 this의 마지막 뜻입니다. 

5강 Arrow function은 function을 대체하는 신문법이 아님
*Arrow function 문법 
자바스크립트에선 함수를 이런 식으로 만들어서 사용합니다.
(1)
function 예쁜함수(){
  //어쩌구
}

(2)
var 예쁜함수 = function(){
  //어쩌구
}
함수는 (1) 또는 (2)처럼 만들고
예쁜함수(); 이렇게 함수를 사용합니다. 
(function 키워드로 시작하는것 말고도 (2)번처럼 변수에다가 함수를 등호=로 집어넣어서 함수를 만들 수 있습니다. )

*근데 ES6 신문법을 사용하면 함수를 이렇게 만들 수도 있습니다. 
var 예쁜함수 = () => {
  //어쩌구
}
function이라는 길고 복잡한 키워드 대신에
=> 이런 예쁜 화살표를 사용해서 함수를 만들어내는 신문법입니다. 

장점1. 함수 본연의 기능을 아주 잘 표현하는 문법입니다.
그래서 arrow function을 쓰시면 입출력기능이 쉽고 예쁘게 표현되지 않습니까.
var 두배만들기 = (x) => { return x * 2 }

console.log( 두배만들기(4) );
console.log( 두배만들기(8) );

장점2. 소괄호 생략이 가능합니다.  
파라미터가 하나라면 소괄호를 생략가능합니다. 
var 두배만들기 = x => { return x * 2 }

console.log( 두배만들기(4) );
console.log( 두배만들기(8) );
이렇게 해도 된다는 소리입니다. 

장점3. 중괄호 생략이 가능합니다.  
중괄호 안에 return 한줄 뿐이라면 중괄호와 return도 생략가능합니다. 
var 두배만들기 = x => x * 2 ;

console.log( 두배만들기(4) );
console.log( 두배만들기(8) );

장점4. arrow function을 쓰면 내부에서 this값을 쓸 때 밖에 있던 this값을 그대로 사용합니다.

8강 변수 신문법 총정리 1. var let const와 선언,할당,범위
var 재선언o 재할당o 범위 function
let 재선언x 재할당o 범위 {}
const 재선언x 재할당x 범위 {}

*Object.freeze() 소괄호에 오브젝트를 담으시면 불변의 Object가 완성됩니다. 
(하지만 오브젝트 내의 오브젝트까지 freeze해주진 않습니다)

*변수의 범위 
변수를 만들면 존재범위가 있습니다. 
var 변수는 존재범위가 function입니다. 
let, const 변수는 존재범위가 거의 모든 {중괄호} 입니다. (for, if, function 등)

function 함수(){
  var 이름 = 'Kim';
  console.log(이름); //가능
}

console.log(이름); //에러
▲ 위의 예제처럼 var 변수는 function 내에서 만들면 function 내에서만 쓸 수 있습니다. 
function 바깥에서 부르면 없다고 나옵니다. 
 
if ( 1 == 1 ){
  let 이름 = 'Kim';
  console.log(이름); //가능
}

console.log(이름); //에러
▲ 위의 예제처럼 let 변수는 {} 중괄호 내에서 만들면 중괄호 내에서만 쓸 수 있습니다. 
중괄호 바깥에서 부르면 없다고 나옵니다. 

9강 변수 신문법 총정리 2. Hoisting, 전역변수, 참조
*자바스크립트 변수, 함수의 Hoisting 현상
자바스크립트는 변수나 함수를 선언하면 Hoisting이라는 현상이 일어납니다. 
자바스크립트는 변수나 함수의 선언부분을 변수의 범위 맨 위로 강제로 끌고가서 가장 먼저 해석합니다.
그게 Hoisting입니다. 

예를 들어봅시다.  

function 함수(){
  
  console.log('hello');
  var 이름 = 'Kim';
  
}
이렇게 함수 내에서 변수를 만들었다고 칩시다. 
근데 자바스크립트가 이 코드를 해석하는 순서는 이렇게 됩니다. 
function 함수(){

  var 이름; 
  console.log('hello');
  이름 = 'Kim';
  
}
변수의 선언 부분을 강제로 변수의 범위 맨 위로 끌고가서 해석하고 지나갑니다. 
우리 눈에 보이진 않지만 자바스크립트는 코드 동작 순서가 이렇습니다.
암튼 이게 Hoisting 현상입니다. 
함수를 만들어도 똑같고, 변수를 let, const로 만들어도 똑같습니다. 

그럼 이 코드는 실행결과가 어떻게될까요? 

<script>
  
  console.log(이름);
  var 이름 = 'Kim';
  console.log(이름);

</script>
뭘까요
콘솔창에 첫째로는 undefined가 출력되고
둘째로는 Kim이 출력됩니다. 
왜냐면 Hoisting 때문에 

var 이름;
console.log(이름);
이름 = 'Kim'
console.log(이름);
이런 순서로 코드가 실행되니까요. 

*변수 여러개 편리하게 만들기
변수를 콤마로 구분하시면 여러개를 동시에 만들 수 있습니다. 

var 이름, 나이, 성별;
이렇게 하면 변수가 3개 생성됩니다. var 키워드 3번 쓰지않아도 되니 코드가 약간 더 줄어드네요. 

var 이름 = 'Kim', 나이, 성별;
선언과 동시에 할당도 하고 싶으면 그냥 이렇게 하시면 됩니다. 

그냥 var let const 키워드를 여러번 안써도 된다는 장점이 있습니다. 

var 이름, 
    나이, 
    성별;
어떤 놈들은 이렇게도 씁니다. 

*전역변수와 변수의 참조
var 나이 = 20;

function 함수(){
  console.log(나이)
}
함수();

지금 함수(){} 안쪽에서 바깥쪽에 있는 나이라는 변수를 가져다 쓸 수 있다는 것입니다. 
함수(){} 안쪽에 나이라는 변수 정의가 있으면 그걸 쓰겠지만 
없으면 자연스럽게 바깥에 있는 변수를 가져다 씁니다.(참조합니다)

12강 자바스크립트가 문자 다루는 신기한 방법 (Template literals)
1. 문자 중간 엔터키 입력이 가능합니다
자바스크립트 문자열은 문자 중간에 엔터키치시면 안됩니다. 
하지만 백틱으로 문자를 만드시면 엔터키가 자유롭게 가능합니다. 
var 문자 = `안녕
하세요`;

2. 문자 중간에 변수를 집어넣을 때 편리합니다. 
자바스크립트 문자열은 문자 중간에 변수를 넣고 싶은 경우 문자를 쪼개서 + 기호로 넣어야합니다.  
하지만 백틱으로 문자를 만드시면 문자 중간에 ${변수명} 이렇게 쉽게 넣을 수 있습니다. 
var 이름 = '손흥민';
var 문자 = `안녕하세요 ${이름} 입니다`;
매우 간단합니다. 
그래서 자바스크립틑 문자로 HTML을 작성하실 때도 유용합니다. 
var 문자 = `
<div>
  <div>
    ${변수명}
  </div>
</div>`;
HTML 템플릿 같은걸 보기쉽게 만들 수 있지요. 

*Tagged Literals
ES6는 tagged literals라고 해서 함수로 문자 해체분석기능을 만들어줄 수도 있습니다. 
문자 중간중간에 있는 단어 순서를 바꾸거나 변수를 제거하거나 할 때 유용합니다. 
var 변수 = '손흥민';

function 해체분석기(){
  return 10 
}

해체분석기`안녕하세요 ${변수} 입니다`;
▲ 맨 마지막줄에서 함수를 실행시킬 때 소괄호가 아니라 문자를 이용해서 함수를 실행시킬 수 있습니다. 
실행할 함수이름을 쓰시고 소괄호 대신 `백틱` 문자를 붙여주시면 됩니다.
그럼 함수가 실행됩니다. 위의 예제코드에선 해체분석기()라는 함수가 실행되고 있습니다.  

그런데 함수를 실행하는거 자체가 신기하긴 한데 왜 하는 거냐면
함수뒤에 `문자`를 붙여 실행하면 그 `문자열`을 해체분석할 수 있기 때문입니다. 
해체분석용 함수를 한번 만들어봅시다. 
var 변수 = '손흥민';

function 해체분석기(문자들, 변수들){
  console.log(문자들);
  console.log(변수들);
}

해체분석기`안녕하세요 ${변수} 입니다`;
▲ 함수의 파라미터 두개를 추가해줍니다. 
이제 이 함수는 막줄처럼 `문자열`을 이용해서 실행시키면 그 `문자열` 해체분석역할을 할 수 있습니다.
첫째 파라미터 문자들은 `백틱` 내의 순수 문자만 골라서 Array로 만들어놓은 파라미터이고, 
둘째 파라미터 변수들은 `백틱` 내의 ${} 변수를 담는 파라미터입니다.
(백틱 내에 변수가 2개 3개다 그러면 파라미터를 뒤에 더 추가해주시면 됩니다)

Q. 첫째 파라미터가 Array라는데 뭘 어떻게 만든 Array인지 이해가 안가요

A. 뭘 기준으로 Array를 만들어주냐면 ${} 기호를 기준으로 양옆에 있는 모든 문자 덩어리를
Array안에 집어넣어준다는 소리입니다. 
각각 파라미터를 출력해보시면 파라미터가 뭘 의미하는지 눈에 보이실겁니다. 
var 변수 = '손흥민';

function 해체분석기(문자들, 변수들){
  console.log(문자들[1] + 변수들);
}

해체분석기`안녕하세요 ${변수} 입니다`;

▲ 그럼 이 코드는 실행하면 콘솔창에 뭐가 출력될까요?
문자들을 모아놓은 Array중 1번째 문자 + 변수를 출력해줄 겁니다.
그래서 '입니다손흥민' 이라는 문자가 출력됩니다. 
이렇게 ``백틱 내의 문자들을 해체해서 내 맘대로 다시 나열할 수 있게 도와주는 함수를 제작한 것입니다. 

13강 Template literals / tagged literals 연습문제 2개와 풀이
*문제 1. 단어 순서를 바꾸는 해체분석기 제작하기
var pants = 20;
var socks = 100;
`바지${pants} 양말${socks}`;

function 해체분석기(글자들, 변수들1, 변수들2){
    console.log(글자들[1] + 변수들1 + 글자들[0] + 변수들2);
}

해체분석기`바지${pants} 양말${socks}`; 

*문제 2. 바지가 0개면 '바지다팔렸어요'라는 문자를 대신 표시해주고 싶습니다. 
var pants = 0;
var socks = 100;
`바지${pants} 양말${socks}`;

function 해체분석기(글자들, 변수들1, 변수들2){
    if(변수들1 == 0){
      console.log(`바지다팔렸어요 양말` + 변수들2);
    }
}
  
  해체분석기`바지${pants} 양말${socks}`;

14강 모든 괄호를 없애주는 Spread Operator 활용방법 1
*ES6 Spread Operator 라는 문법을 알아봅시다
그냥 마침표를 연달아서 3개... 찍으시면 그게 spread operator라는 문법입니다.
펼침연산자, "괄호제거 해주는 연산자" 입니다. Array에 붙여보도록 합시다. 

var 어레이 = ['hello', 'world'];
console.log(어레이);
console.log(...어레이);
 
그럼 어레이라는 array에 붙어있던 괄호를 제거해줍니다. 
▲ 3번줄처럼 spread operator를 붙여서 출력해보시면 괄호가 제거된 'hello', 'world'만 콘솔창에 출력됩니다. 
이게 spread operator의 기능 끝입니다.

문자에 붙이면 문자에 붙은 괄호를 제거해줍니다. 

var 문자 = 'hello';
console.log(문자[0]);
console.log(문자[1]);
 
문자를 이런식으로 array처럼 출력할 수 있다는거 아셨습니까.
그럼 문자에 spread를 붙이면 어떻게 될까요? 대괄호를 제거해줍니다. 

var 문자 = 'hello';
console.log(문자);
console.log(...문자);
 
위 코드 셋째줄을 출력해보면 콘솔창에 h e l l o 라는 문자들이 출력됩니다. 
console.log('h', 'e', 'l', 'l', 'o') 이렇게 한거랑 똑같다고 보시면 됩니다. 
그래서 spread를 문자에 붙이면 알파벳을 하나씩 펼쳐줍니다.
(혹은 그냥 문자의 안보이는 대괄호를 제거해준다고 외우세요)

장점1. Array 합치기/복사에 매우 자주 씁니다.
array 두개를 합치고 싶으면 어떻게 합니까.

var a = [1,2,3];
var b = [4,5];
var c = [여기엔 1,2,3,4,5 가 들어오게 만들려면?];

옛날엔 뭐 이상한 방식을 마구 썼는데 spread operator를 사용하시면 매우 쉽습니다. 
spread operator가 뭐랬죠? 대괄호 제거해주는거라면서요. 그럼 이렇게 써볼게요.

var a = [1,2,3];
var b = [4,5];
var c = [...a, ...b];

이렇게 한 뒤에 c라는 어레이를 출력해보면 [1,2,3,4,5]가 되어있습니다. 
... 연산자를 이용해서 괄호를 없앤 a와 b를 집어넣는다는 소리입니다. 어레이 합치기 완성입니다.
▼ a라는 어레이를 복사해서 b를 만들고 싶으면 보통 이렇게 하지않을까요

var a = [1,2,3];
var b = a;

console.log(a);
console.log(b);
등호 = 를 이용하시면 쉽게 a에 있던 값을 b에 집어넣을 수 있습니다. ( [1,2,3] 복사완료!)
그런데 자바스크립트에선 복사를 이렇게 하시면 큰일납니다. 
등호로 복사를 하시면 a와 b 변수는 [1,2,3]을 각각 따로 하나씩 가진게 아니라 값 공유가 일어납니다. 
그래서 a라는 array를 수정하면 b도 똑같이 바뀌는 신기한 버그가 일어납니다. 

그래서 값을 공유하지 않고 각각 독립적인 값을 저장하도록 spread를 이용하시면 되겠습니다. 

var a = [1,2,3];
var b = [...a];

console.log(a);
console.log(b)
spread를 이용해서 a값의 괄호를 제거해준 다음에 다시 괄호를 씌우는 겁니다. 
그렇게 하시면 아까처럼 a와 b 변수의 값 공유가 일어나지 않습니다. 

장점2. Object 합치기/복사에 매우 자주 씁니다.
여러분 object 두개를 합치고 싶으면 어떻게 합니까.

var o1 = { a : 1, b : 2 };
var o2 = { c : 3, 그리고 o1에 있는거 전부.. }
o2를 만들고 싶은데 o1에 있던 내용들을 그대로 가져다가 추가하고 싶습니다. 
그럼 어떻게 해야되냐면 고민하지말고 spread operator를 떠올리시면 됩니다. 
이 연산자는 대괄호 뿐만아니라 중괄호도 제거해줍니다. 

var o1 = { a : 1, b : 2 };
var o2 = { c : 3, ...o1 };
console.log(o2);
o2라는 오브젝트를 출력해보면 a, b, c키값이 다 들어있습니다. 
왜냐면 o1오브젝트를 spread 연산자를 이용해 괄호를 벗겨서 추가했기 때문입니다. 
오브젝트 shallow copy도 비슷한 방식으로 합니다. 
결론은 오브젝트나 어레이나 spread를 유용하게 사용하실 수 있습니다. 

참고1. 
오브젝트의 key값 중복이 발생하면 어떻게될까요?

var o1 = { a : 1, b : 2};
var o2 = { a : 3, ...o1 };
console.log(o2);
o2를 o1항목을 추가해서 만들고 싶은데 a라는 키값이 이미 있는겁니다.
이렇게 a라는 값이 중복이 발생하면 무조건 뒤에 오는 a가 이깁니다. 
그래서 출력해보면 a : 1 이라는 자료가 담겨져있습니다.

참고2. 
spread 연산자는 함수소괄호, 오브젝트 중괄호내, 어레이 대괄호내에서 보통 사용하셔야합니다. 
다른 곳에서 그냥 썼다간 에러가날 수 있습니다. 

15강 Spread Operator 활용방법 2 & apply, call 함수 알아보기
장점3. array를 파라미터형태로 집어넣고 싶을 때 씁니다. 
function 더하기(a,b,c){
   console.log(a + b + c)
}
더하기(1,2,3);
파라미터를 3개 받아와서 전부 더해주는 더하기라는 함수를 만들어봤습니다. 
그런데 여기 파라미터를 집어넣을 때
직접 1,2,3이라고 작성해서 넣는게 아니라
이미 존재하는 array에 있던 내부 자료들을 쏙 집어넣고 싶으면 어떻게하나요?
그니까 예를 들면...  

function 더하기(a,b,c){
   console.log(a + b + c)
}

var 어레이 = [10, 20, 30];
어레이라는 자료 안에 있는 모든 숫자 10,20,30을 더하기() 함수의 파라미터로 집어넣으려면 어떻게 해야합니까.
더하기(10,20,30); 
이렇게 직접 손으로 적거나
더하기(어레이[0], 어레이[1], 어레이[2]); 
이렇게 하거나 해야겠죠?

근데 그게 귀찮으시면 spread 연산자를 쓰시면 됩니다. 

function 더하기(a,b,c){
   console.log(a + b + c)
}

var 어레이 = [10, 20, 30];
더하기(...어레이);
그러면 출력했을 때 10, 20, 30을 더해준 결과가 잘 출력됩니다. 

▼ spread 연산자가 없던 시절엔 이런 식으로 작성했었습니다. 

function 더하기(a,b,c){
   console.log(a + b + c)
}

var 어레이 = [10, 20, 30];
더하기(...어레이);  //요즘방식
더하기.apply(undefined, 어레이);  //옛날방식
apply라는 이상한 함수를 뒤에 붙여서 실행을 했었는데 이게 뭔지 자세히 알아보도록 합시다. 
왜냐면 여러분 나중에 객체지향 문법같은거 배우실 때 가끔 등장하는 함수들이니까요. 

*apply, call 함수가 뭔지 알아보자
일단 예시를 들기 위해 오브젝트를 두개 만들어봅시다. 
var person = {
    인사 : function(){
      console.log(this.name + '안녕')
    }
}
  
var person2 = {
    name : '손흥민'
}
person이라는 오브젝트에는 멋진 인사라는 함수를 만들어 넣었고
person2는 보잘것없이 그냥 name : '손흥민' 이라는 자료만 넣었습니다. 
그런데 person에 만들어놓은 멋진 person.인사()라는 함수를 person2에서도 쓰고 싶습니다. 
그럼 어떻게 해야할까요? 

person2에다가 직접 인사()라는 함수를 코딩해서 집어넣으면 되겠죠? 
근데 그게 불가능한 경우가 가끔 있습니다. (혹은 귀찮거나)
그럴 때 apply를 쓰시면 됩니다.
apply는 이 함수를 실행하는데.. 저기 오브젝트에다가 적용해서 실행해주세요~ 라는 뜻입니다. 
그래서 한번 시도해봅시다. 

var person = {
    인사 : function(){
      console.log(this.name + '안녕')
    }
}
  
var person2 = {
    name : '손흥민'
}

person.인사.apply(person2);
▲ 맨 마지막줄에 적은 코드가 뭔 의미냐면
person.인사()라는 함수를 쓰는데 person2라는 오브젝트에 적용해서 실행해라~ 
또는 person.인사()라는 함수를 쓰는데 person2라는 오브젝트에 있는 함수처럼 실행해라~ 라는 뜻입니다. 

apply 함수의 사용법은
실행할함수.apply(적용할곳);
이라고 보시면 됩니다. 
이제 apply만 기억해주시면 여러가지 유용한 함수들을 내가 원하는 곳에 붙여서 쉽게 실행가능합니다. 
근데 이거랑 아주 똑같은 기능을 하는 함수가 하나 더 있습니다. call 이라고 있어얌 

var person = {
    인사 : function(){
      console.log(this.name + '안녕')
    }
}
  
var person2 = {
    name : '손흥민'
}

person.인사.apply(person2);
person.인사.call(person2);
▲ apply와 call은 실행 결과도 똑같고 사용법도 똑같습니다. 

하지만 차이점이 하나 있는데, 내가 person.인사()에 파라미터를 넣어서 실행하고 싶은 경우에는 

person.인사.apply(person2, 파라미터);
person.인사.call(person2, 파라미터);

이렇게 실행하셔야하는데
이 때 apply는 파라미터를 [array]로 한꺼번에 집어넣을 수 있고
call은 그냥 1,2,3 이렇게 일반 함수처럼 만 집어넣을 수 있습니다. 

var person = {
    인사 : function(){
      console.log(this.name + '안녕')
    }
}
  
var person2 = {
    name : '손흥민'
}

person.인사.apply(person2, [1,2,3]);
person.인사.call(person2, 1,2,3);
▲ 파라미터 집어넣는 방법만 좀 차이가 있지 아무튼 call, apply의 실행내용은 똑같습니다. 
apply함수는 저렇게 어레이 내의 데이터를 파라미터로 한꺼번에 집어넣을 수 있다는 유용한 기능을 제공하기 때문에 
옛날 개발자들이 파라미터가 많은 함수를 만들 때 자주 사용했습니다. 

그럼 이제 아까 함수에 array 집어넣는 예제가 이해가 가기 시작합니다. 

function 더하기(a,b,c){
   console.log(a + b + c)
}

var 어레이 = [10, 20, 30];
더하기(...어레이);  //요즘방식 넣기
더하기.apply(undefined, 어레이);  //옛날방식 넣기

이제 이거 옛날방식인
더하기.apply(undefined, 어레이) 
가 무슨 뜻인지 아시겠습니까.
더하기() 함수를 실행하는데 undefined에 적용해서 실행해주시고요 파라미터로 어레이를 집어넣어주세요~ 라는 뜻입니다. 
이러면 편법같은 느낌이 들지만 array를 풀어헤쳐서 파라미터로 집어넣으실 수 있습니다.  

Q. 잉 근데 undefined에 적용하는건 뭔소리인가요?
A. 비워두면 문제가 생기기 때문에 아무 값이나 집어넣은 것입니다.

결론은 spread 연산자가 생긴게 다행입니다